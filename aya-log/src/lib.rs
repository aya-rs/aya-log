//! A logging framework for eBPF programs.
//!
//! This is the user space side of the [Aya] logging framework. For the eBPF
//! side, see the `aya-log-ebpf` crate.
//!
//! `aya-log` provides the [BpfLogger] type, which reads log records created by
//! `aya-log-ebpf` and logs them using the [log] crate. Any logger that
//! implements the [Log] trait can be used with this crate.
//!
//! # Example:
//!
//! This example uses the [simplelog] crate to log messages to the terminal.
//!
//! ```no_run
//! # let mut bpf = aya::Bpf::load(&[]).unwrap();
//! use simplelog::{ColorChoice, ConfigBuilder, LevelFilter, TermLogger, TerminalMode};
//! use aya_log::BpfLogger;
//!
//! // initialize simplelog::TermLogger as the default logger
//! TermLogger::init(
//!     LevelFilter::Debug,
//!     ConfigBuilder::new()
//!         .set_target_level(LevelFilter::Error)
//!         .set_location_level(LevelFilter::Error)
//!         .build(),
//!     TerminalMode::Mixed,
//!     ColorChoice::Auto,
//! )
//! .unwrap();
//!
//! // start reading aya-log records and log them using the default logger
//! BpfLogger::init(&mut bpf).unwrap();
//! ```
//!
//! With the following eBPF code:
//!
//! ```ignore
//! # let ctx = ();
//! use aya_log_ebpf::{debug, error, info, trace, warn};
//!
//! error!(&ctx, "this is an error message ðŸš¨");
//! warn!(&ctx, "this is a warning message âš ï¸");
//! info!(&ctx, "this is an info message â„¹ï¸");
//! debug!(&ctx, "this is a debug message ï¸ðŸ");
//! trace!(&ctx, "this is a trace message ðŸ”");
//! ```
//! Outputs:
//!
//! ```text
//! 21:58:55 [ERROR] xxx: [src/main.rs:35] this is an error message ðŸš¨
//! 21:58:55 [WARN] xxx: [src/main.rs:36] this is a warning message âš ï¸
//! 21:58:55 [INFO] xxx: [src/main.rs:37] this is an info message â„¹ï¸
//! 21:58:55 [DEBUG] (7) xxx: [src/main.rs:38] this is a debug message ï¸ðŸ
//! 21:58:55 [TRACE] (7) xxx: [src/main.rs:39] this is a trace message ðŸ”
//! ```
//!
//! [Aya]: https://docs.rs/aya
//! [simplelog]: https://docs.rs/simplelog
//! [Log]: https://docs.rs/log/0.4.14/log/trait.Log.html
//! [log]: https://docs.rs/log
//!
use std::{borrow::Cow, convert::TryInto, io, mem, net::Ipv4Addr, ptr, str, sync::Arc};

use aya_log_common::{ArgType, RecordField, LOG_BUF_CAPACITY, LOG_FIELDS};
use bytes::BytesMut;
use log::{error, Level, Log, Record};
use thiserror::Error;

use aya::{
    maps::{
        perf::{AsyncPerfEventArray, PerfBufferError},
        MapError,
    },
    util::online_cpus,
    Bpf, Pod,
};

/// Log messages generated by `aya_log_ebpf` using the [log] crate.
///
/// For more details see the [module level documentation](crate).
pub struct BpfLogger;

impl BpfLogger {
    /// Starts reading log records created with `aya-log-ebpf` and logs them
    /// with the default logger. See [log::logger].
    pub fn init(bpf: &mut Bpf) -> Result<BpfLogger, Error> {
        BpfLogger::init_with_logger(bpf, DefaultLogger {})
    }

    /// Starts reading log records created with `aya-log-ebpf` and logs them
    /// with the given logger.
    pub fn init_with_logger<T: Log + 'static>(
        bpf: &mut Bpf,
        logger: T,
    ) -> Result<BpfLogger, Error> {
        let logger = Arc::new(logger);
        let mut logs: AsyncPerfEventArray<_> = bpf.map_mut("AYA_LOGS")?.try_into()?;

        for cpu_id in online_cpus().map_err(Error::InvalidOnlineCpu)? {
            let mut buf = logs.open(cpu_id, None)?;

            let log = logger.clone();
            tokio::spawn(async move {
                let mut buffers = (0..10)
                    .map(|_| BytesMut::with_capacity(LOG_BUF_CAPACITY))
                    .collect::<Vec<_>>();

                loop {
                    let events = buf.read_events(&mut buffers).await.unwrap();

                    #[allow(clippy::needless_range_loop)]
                    for i in 0..events.read {
                        let buf = &mut buffers[i];
                        log_buf(buf, &*log).unwrap();
                    }
                }
            });
        }

        Ok(BpfLogger {})
    }
}

#[derive(Copy, Clone, Debug)]
struct DefaultLogger;

impl Log for DefaultLogger {
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        log::logger().enabled(metadata)
    }

    fn log(&self, record: &Record) {
        log::logger().log(record)
    }

    fn flush(&self) {
        log::logger().flush()
    }
}

/// All display hints
#[derive(Clone, Debug, PartialEq)]
pub enum DisplayHint {
    /// `:ipv4`, `:IPv4`
    IPv4,
}

/// A parsed formatting parameter (contents of `{` `}` block).
#[derive(Clone, Debug, PartialEq)]
pub struct Parameter {
    /// The display hint, e.g. ':ipv4', ':IPv4'.
    pub hint: Option<DisplayHint>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum Fragment<'a> {
    /// A literal string (eg. `"literal "` in `"literal {}"`).
    Literal(Cow<'a, str>),

    /// A format parameter.
    Parameter(Parameter),
}

fn push_literal<'a>(
    frag: &mut Vec<Fragment<'a>>,
    unescaped_literal: &'a str,
) -> Result<(), Cow<'static, str>> {
    // Replace `{{` with `{` and `}}` with `}`. Single braces are errors.

    // Scan for single braces first. The rest is trivial.
    let mut last_open = false;
    let mut last_close = false;
    for c in unescaped_literal.chars() {
        match c {
            '{' => last_open = !last_open,
            '}' => last_close = !last_close,
            _ => {
                if last_open {
                    return Err("unmatched `{` in format string".into());
                }
                if last_close {
                    return Err("unmatched `}` in format string".into());
                }
            }
        }
    }

    // Handle trailing unescaped `{` or `}`.
    if last_open {
        return Err("unmatched `{` in format string".into());
    }
    if last_close {
        return Err("unmatched `}` in format string".into());
    }

    // FIXME: This always allocates a `String`, so the `Cow` is useless.
    let literal = unescaped_literal.replace("{{", "{").replace("}}", "}");
    frag.push(Fragment::Literal(literal.into()));
    Ok(())
}

/// Parses the display hint (e.g. the `ipv4` in `{:ipv4}`).
fn parse_display_hint(s: &str) -> Option<DisplayHint> {
    Some(match s {
        "ipv4" => DisplayHint::IPv4,
        "IPv4" => DisplayHint::IPv4,
        _ => return None,
    })
}

/// Parse `Param` from `&str`
///
/// * example `input`: `:hint` (note: no curly braces)
fn parse_param(mut input: &str) -> Result<Parameter, Cow<'static, str>> {
    const HINT_PREFIX: &str = ":";

    // Then, optional hint
    let mut hint = None;

    if input.starts_with(HINT_PREFIX) {
        // skip the prefix
        input = &input[HINT_PREFIX.len()..];
        if input.is_empty() {
            return Err("malformed format string (missing display hint after ':')".into());
        }

        hint = Some(match parse_display_hint(input) {
            Some(a) => a,
            None => return Err(format!("unknown display hint: {:?}", input).into()),
        });
    } else if !input.is_empty() {
        return Err(format!("unexpected content {:?} in format string", input).into());
    }

    Ok(Parameter { hint })
}

pub fn parse<'a>(format_string: &'a str) -> Result<Vec<Fragment<'a>>, Cow<'static, str>> {
    let mut fragments = Vec::new();

    // Index after the `}` of the last format specifier.
    let mut end_pos = 0;

    let mut chars = format_string.char_indices();
    while let Some((brace_pos, ch)) = chars.next() {
        if ch != '{' {
            // Part of a literal fragment.
            continue;
        }

        // Peek at the next char.
        if chars.as_str().starts_with('{') {
            // Escaped `{{`, also part of a literal fragment.
            chars.next(); // Move after both `{`s.
            continue;
        }

        if brace_pos > end_pos {
            // There's a literal fragment with at least 1 character before this parameter fragment.
            let unescaped_literal = &format_string[end_pos..brace_pos];
            push_literal(&mut fragments, unescaped_literal)?;
        }

        // Else, this is a format specifier. It ends at the next `}`.
        let len = chars
            .as_str()
            .find('}')
            .ok_or("missing `}` in format string")?;
        end_pos = brace_pos + 1 + len + 1;

        // Parse the contents inside the braces.
        let param_str = &format_string[brace_pos + 1..][..len];
        let param = parse_param(param_str)?;
        fragments.push(Fragment::Parameter(param));
    }

    // Trailing literal.
    if end_pos != format_string.len() {
        push_literal(&mut fragments, &format_string[end_pos..])?;
    }

    Ok(fragments)
}

#[derive(Error, Debug)]
pub enum Error {
    #[error("error opening log event array")]
    MapError(#[from] MapError),

    #[error("error opening log buffer")]
    PerfBufferError(#[from] PerfBufferError),

    #[error("invalid /sys/devices/system/cpu/online format")]
    InvalidOnlineCpu(#[source] io::Error),
}

fn log_buf(mut buf: &[u8], logger: &dyn Log) -> Result<(), ()> {
    let mut target = None;
    let mut level = Level::Trace;
    let mut module = None;
    let mut file = None;
    let mut line = None;
    let mut log = None;
    let mut num_args = None;

    for _ in 0..LOG_FIELDS {
        let (attr, rest) = unsafe { TagLenValue::<'_, RecordField>::try_read(buf)? };

        match attr.tag {
            RecordField::Target => {
                target = Some(std::str::from_utf8(attr.value).map_err(|_| ())?);
            }
            RecordField::Level => {
                level = unsafe { ptr::read_unaligned(attr.value.as_ptr() as *const _) }
            }
            RecordField::Module => {
                module = Some(std::str::from_utf8(attr.value).map_err(|_| ())?);
            }
            RecordField::File => {
                file = Some(std::str::from_utf8(attr.value).map_err(|_| ())?);
            }
            RecordField::Line => {
                line = Some(u32::from_ne_bytes(attr.value.try_into().map_err(|_| ())?));
            }
            RecordField::NumArgs => {
                num_args = Some(usize::from_ne_bytes(attr.value.try_into().map_err(|_| ())?));
            }
            RecordField::Log => {
                log = Some(std::str::from_utf8(attr.value).map_err(|_| ())?);
            }
        }

        buf = rest;
    }

    let log_msg = log.ok_or(())?;
    let full_log_msg = match num_args {
        Some(n) => {
            let fragments = parse(log_msg).map_err(|_| ())?;
            let mut msg = String::new();
            let mut arg = 0;

            for fragment in fragments {
                match fragment {
                    Fragment::Literal(s) => msg.push_str(&s),
                    Fragment::Parameter(p) => {
                        let (attr, rest) = unsafe { TagLenValue::<'_, ArgType>::try_read(buf)? };

                        match attr.tag {
                            ArgType::I8 => {
                                msg.push_str(
                                    &i8::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::I16 => {
                                msg.push_str(
                                    &i16::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::I32 => {
                                msg.push_str(
                                    &i32::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::I64 => {
                                msg.push_str(
                                    &i64::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::I128 => {
                                msg.push_str(
                                    &i128::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::Isize => {
                                msg.push_str(
                                    &isize::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::U8 => {
                                msg.push_str(
                                    &u8::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::U16 => {
                                msg.push_str(
                                    &u16::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::U32 => {
                                let val =
                                    u32::from_ne_bytes(attr.value.try_into().map_err(|_| ())?);
                                match p.hint {
                                    Some(DisplayHint::IPv4) => {
                                        let ip = Ipv4Addr::from(val);
                                        msg.push_str(&ip.to_string());
                                    }
                                    None => {
                                        msg.push_str(&val.to_string());
                                    }
                                }
                            }
                            ArgType::U64 => {
                                msg.push_str(
                                    &u64::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::U128 => {
                                msg.push_str(
                                    &u128::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::Usize => {
                                msg.push_str(
                                    &usize::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::F32 => {
                                msg.push_str(
                                    &f32::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::F64 => {
                                msg.push_str(
                                    &f64::from_ne_bytes(attr.value.try_into().map_err(|_| ())?)
                                        .to_string(),
                                );
                            }
                            ArgType::Str => match str::from_utf8(attr.value) {
                                Ok(v) => msg.push_str(&v.to_string()),
                                Err(e) => error!("received invalid utf8 string: {}", e),
                            },
                        }

                        buf = rest;
                        arg += 1;
                    }
                }
            }

            if arg != n {
                error!(
                    "received invalid number of arguments: expected {}, got {}",
                    n, arg
                );
                return Err(());
            }

            msg
        }
        None => log_msg.to_string(),
    };

    logger.log(
        &Record::builder()
            .args(format_args!("{}", full_log_msg))
            .target(target.ok_or(())?)
            .level(level)
            .module_path(module)
            .file(file)
            .line(line)
            .build(),
    );
    logger.flush();
    Ok(())
}

struct TagLenValue<'a, T: Pod> {
    tag: T,
    value: &'a [u8],
}

impl<'a, T: Pod> TagLenValue<'a, T> {
    unsafe fn try_read(mut buf: &'a [u8]) -> Result<(TagLenValue<'a, T>, &'a [u8]), ()> {
        if buf.len() < mem::size_of::<T>() + mem::size_of::<usize>() {
            return Err(());
        }

        let tag = ptr::read_unaligned(buf.as_ptr() as *const T);
        buf = &buf[mem::size_of::<T>()..];

        let len = usize::from_ne_bytes(buf[..mem::size_of::<usize>()].try_into().unwrap());
        buf = &buf[mem::size_of::<usize>()..];

        if buf.len() < len {
            return Err(());
        }

        Ok((
            TagLenValue {
                tag,
                value: &buf[..len],
            },
            &buf[len..],
        ))
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use aya_log_common::{write_record_header, write_record_message, WriteToBuf};
    use log::logger;
    use testing_logger;

    #[test]
    fn test_parse() {
        assert_eq!(
            parse("foo {} bar"),
            Ok(vec![
                Fragment::Literal("foo ".into()),
                Fragment::Parameter(Parameter {
                    hint: None
                }),
                Fragment::Literal(" bar".into())
            ])
        );
        assert_eq!(
            parse("foo {:ipv4} bar"),
            Ok(vec![
                Fragment::Literal("foo ".into()),
                Fragment::Parameter(Parameter {
                    hint: Some(DisplayHint::IPv4)
                }),
                Fragment::Literal(" bar".into())
            ])
        )
    }

    fn new_log(msg: &str, args: usize) -> Result<(usize, Vec<u8>), ()> {
        let mut buf = vec![0; 8192];
        let mut len = write_record_header(
            &mut buf,
            "test",
            aya_log_common::Level::Info,
            "test",
            "test.rs",
            123,
            args,
        )?;
        len += write_record_message(&mut buf[len..], msg)?;
        Ok((len, buf))
    }

    #[test]
    fn test_str() {
        testing_logger::setup();
        let (_, input) = new_log("test", 0).unwrap();
        let logger = logger();
        let _ = log_buf(&input, logger);
        testing_logger::validate(|captured_logs| {
            assert_eq!(captured_logs.len(), 1);
            assert_eq!(captured_logs[0].body, "test");
            assert_eq!(captured_logs[0].level, Level::Info);
        });
    }

    #[test]
    fn test_str_with_args() {
        testing_logger::setup();
        let (len, mut input) = new_log("hello {}", 1).unwrap();
        let name = "test";
        (*name).write(&mut input[len..]).unwrap();
        let logger = logger();
        let _ = log_buf(&input, logger);
        testing_logger::validate(|captured_logs| {
            assert_eq!(captured_logs.len(), 1);
            assert_eq!(captured_logs[0].body, "hello test");
            assert_eq!(captured_logs[0].level, Level::Info);
        });
    }

    #[test]
    fn test_str_with_hints() {
        testing_logger::setup();
        let (len, mut input) = new_log("hello {:ipv4}", 1).unwrap();
        let ip: u32 = 1480603102;
        ip.write(&mut input[len..]).unwrap();
        let logger = logger();
        let _ = log_buf(&input, logger);
        testing_logger::validate(|captured_logs| {
            assert_eq!(captured_logs.len(), 1);
            assert_eq!(captured_logs[0].body, "hello 88.64.53.222");
            assert_eq!(captured_logs[0].level, Level::Info);
        });
    }
}
